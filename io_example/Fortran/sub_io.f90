! For reading subhalo catalogues generated by BoundTracing code.
! Note the SubIDs and HaloIDs all start from 0 as in C language.
!  Thus the corresponding arrays here are allocated with subscripts
!  starting from 0 rather than from 1 which is fortran default.
!  sp2pro is allocated from Npro,pro2dest from -1,
!  corresponding to their own subID range.
!  This way, you can access each subhalo's corresponding information 
!  using its SubID exactly, rather than appealing to SubID+1 or something.
!
! **CAUTION: whether the integers and reals are 4 or 8 bytes depends on the 
!    parameters for the simulation (in param/paramRUNNAME.h). need to manually 
!    adjust this for each run. check param/paramRUNNAME.h to see if 
!    HBT_INT8 and HBT_REAL8 are defined. ***
!!

module sub_io
implicit none
type Chain_data 
	integer*4 ProSubID      !progenitor subhalo id at the immediate previous snapshot; 
							!use sp2pro to convert if ProSubID>=Nsubs_pro
	integer*4 HostID        !subhalo's host halo id at current snapshot
end type Chain_data

type Hierarchy
	integer*4 nibs	    !its host sub
	integer*4 pre	    !its previous sibling
	integer*4 next	    !its next sibling
	integer*4 sub	    !its sub-in-sub
end type Hierarchy

type SubProperty
	real*4 CoM(3)   !center of mass position (comoving), in kpc/h
	real*4 VCoM(3)  !CoM velocity (physical), in km/s
	real*4 Pot      !average gavitational potential per unit mass per particle (GM/R_physical)
	real*4 Kin      !average Kinetic energy per unit mass per particle (0.5*V_physical^2)
	real*4 AM(3)    !average angular momentum per unit mass per particle (R_physical x V_physical)
end type SubProperty

type SUBCATALOGUE
	integer*4 Ngroups
	integer*4 Nsubs
	integer*4 Nids                                 !total number of particles
	integer*4,allocatable:: GrpLen_Sub(:)          !number of subs in a group
	integer*4,allocatable:: GrpOffset_Sub(:)       !sub index offset of a group
	integer*4,allocatable:: SubLen(:)              !number of particles in each subhalo
	integer*4,allocatable:: SubOffset(:)           !the starting position in SubPIDs to store each subhalo's particles 

	integer*4,allocatable:: SubRank(:)             !subhalo's rank according to mass, most massive has rank=0,least massive has rank=Nsub-1
	type (Chain_data),allocatable:: HaloChains(:)  !subhalo's progenitor and host
	
	type (Hierarchy),allocatable:: sub_hierarchy(:)  !merging hierarchy
	
	type (SubProperty),allocatable:: Property(:)     !physical parameters
	
	integer*4,allocatable:: SubPIDs(:)         !particle IDs in this subcatalogue; 
	
	integer*4 Nbirth               !number of new-born subhalos
	integer*4 NQuasi               !number of quasi-subhalos (without a host fof)
	integer*4 Ndeath               !number of dead subhalos from last snapshot
	integer*4 Nsplitter            !number of splitted-out subs from last snap
end type SUBCATALOGUE

contains
subroutine load_sub_catalogue(Nsnap, Cat, SubCatPath)
	integer*4 Nsnap
	type (SUBCATALOGUE) Cat
	character(Len=*) SubCatPath
	character(Len=1024):: subfile,snum
	integer*4 i

	write(snum,'(I3)') Nsnap
	do i=1,3 
	 if (snum(i:i) .eq. ' ') then 
		snum(i:i)='0'
	 end if
	end do
	subfile=trim(SubCatPath)//'/subcat_'//trim(snum)
	open(unit=20,file=subfile,form='unformatted',status='old',action='read',access='stream')

	read(20) Cat%Ngroups,Cat%Nsubs,Cat%Nids
	allocate(Cat%GrpOffset_Sub(0:Cat%Ngroups-1))
	allocate(Cat%GrpLen_Sub(0:Cat%Ngroups-1))
	allocate(Cat%SubLen(0:Cat%Nsubs-1))
	allocate(Cat%SubOffset(0:Cat%Nsubs-1))
	allocate(Cat%SubRank(0:Cat%Nsubs-1))	
	allocate(Cat%HaloChains(0:Cat%Nsubs-1))
	allocate(Cat%sub_hierarchy(0:Cat%Nsubs-1))
	allocate(Cat%Property(0:Cat%Nsubs-1))
	allocate(Cat%SubPIDs(0:Cat%Nids-1)) !to get the first particle in each sub, use SubPIDs(SubOffset(SubID))
	read(20) Cat%GrpLen_Sub,Cat%GrpOffset_Sub
	read(20) Cat%SubLen,Cat%SubOffset
	read(20) Cat%SubRank,Cat%HaloChains,Cat%sub_hierarchy,Cat%Property
	read(20) Cat%SubPIDs
	read(20) Cat%Nbirth,Cat%NQuasi,Cat%Ndeath,Cat%Nsplitter 
	close(20)
end subroutine load_sub_catalogue

subroutine free_sub_catalogue(subcat)
	type (SUBCATALOGUE) subcat
	deallocate(subcat%GrpOffset_Sub)
	deallocate(subcat%GrpLen_Sub)
	deallocate(subcat%SubLen)
	deallocate(subcat%SubRank)
	deallocate(subcat%HaloChains)
	deallocate(subcat%sub_hierarchy)
	deallocate(subcat%Property)
	deallocate(subcat%SubPIDs)
end subroutine free_sub_catalogue

subroutine load_pro2dest(Nsnap_pro,pro2dest,Nsubs,subcatdir)
!load the table for finding descendent subhalos
	integer*4:: Nsnap_pro,i
	integer*4,allocatable,intent(out):: pro2dest(:)
	integer*4,intent(out)::Nsubs   !Nsubs=Npro+Nspl
	character(*) subcatdir
	character(1024) filename,snum

	write(snum,'(I3)') Nsnap_pro
	do i=1,3 
	 if (snum(i:i) .eq. ' ') then 
		snum(i:i)='0'
	 end if
	end do
	filename=trim(subcatdir)//'/pro2dest/pro2dest_'//trim(snum)
	open(unit=20,file=filename,form='unformatted',status='old',action='read',access='stream')

	read(20) Nsubs
	allocate(pro2dest(-1:Nsubs-1))
	pro2dest(-1)=-1
	read(20) pro2dest(0:Nsubs-1)
	close(20)
end subroutine load_pro2dest

subroutine free_pro2dest(pro2dest)
	integer*4,allocatable:: pro2dest(:)
	deallocate(pro2dest)
end subroutine free_pro2dest

subroutine load_sp2pro(Nsnap_dest,Npro,Nsplitter_dest, sp2pro,subcatdir)
	integer*4 Nsnap_dest,i
	integer*4,intent(out):: Npro,Nsplitter_dest
	integer*4,allocatable,intent(out):: sp2pro(:)
	character(*) subcatdir
	character(1024) filename,snum

	!*	Npro=SubCatPro.Nsubs;	Nsplitter_dest=SubCatDest.Nsplitter
	!*  sp2pro(ProSubID) fixes ProSubID to the valid subid if ProSubID>=Npro;
	!*  returns NULL if Nsplitter==0

	write(snum,'(I3)') Nsnap_dest
	do i=1,3 
	 if (snum(i:i) .eq. ' ') then 
		snum(i:i)='0'
	 end if
	end do
	filename=trim(subcatdir)//'/splitters/sp2pro_'//trim(snum)
	open(unit=20,file=filename,form='unformatted',status='old',action='read',access='stream')
		
	read(20) Nsplitter_dest,Npro	
	if(Nsplitter_dest.eq.0) then
		allocate(sp2pro(1))
	else
		allocate(sp2pro(Npro:Npro+Nsplitter_dest-1))
		read(20) sp2pro
	end if
	close(20)
end subroutine load_sp2pro

subroutine free_sp2pro(sp2pro)
	integer*4,allocatable::sp2pro(:)
	deallocate(sp2pro)
end subroutine free_sp2pro

end module sub_io
